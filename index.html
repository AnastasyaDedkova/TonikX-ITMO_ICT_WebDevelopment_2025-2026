
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.20">
    
    
      
        <title>Отчет</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.e53b48f4.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#1-web-" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="." title="Отчет" class="md-header__button md-logo" aria-label="Отчет" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Отчет
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Главная
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="." title="Отчет" class="md-nav__button md-logo" aria-label="Отчет" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Отчет
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="." class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Главная
    
  </span>
  

      </a>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="1-web-">Лабораторная работа 1 по предмету Web-программирование</h1>
<h1 id="1">Задание 1.</h1>
<hr />
<h2 id="_1">Описание</h2>
<p>Реализованы клиентская и серверная части приложения на Python с использованием библиотеки <strong>socket</strong> и протокола <strong>UDP</strong>.<br />
Клиент отправляет серверу сообщение <code>"Hello, server"</code>, которое отображается на стороне сервера.<br />
В ответ сервер отправляет сообщение <code>"Hello, client"</code>, и оно отображается у клиента.</p>
<h2 id="_2">Требования</h2>
<ul>
<li>Python 3.6+</li>
<li>Стандартные библиотеки:</li>
<li><code>socket</code></li>
</ul>
<h2 id="_3">Структура проекта</h2>
<ul>
<li><code>server.py</code> — код сервера</li>
<li><code>client.py</code> — код клиента</li>
</ul>
<h2 id="_4">Как работает сервер</h2>
<ol>
<li>Сервер создаёт UDP-сокет и слушает порт <code>9090</code>.</li>
<li>Клиент создаёт UDP-сокет и отправляет строку <code>"Hello, server"</code> на адрес <code>localhost:9090</code>.</li>
<li>Сервер принимает сообщение, выводит его в консоль и отправляет обратно строку <code>"Hello, client"</code>.</li>
<li>Клиент принимает ответ и выводит его в консоль.</li>
</ol>
<h2 id="_5">Запуск сервера</h2>
<h3 id="1_1">Шаг 1: Запуск сервера</h3>
<p>Откройте терминал и выполните:</p>
<pre><code class="language-bash">cd Task1
python server.py
</code></pre>
<p>Вывод будет таким</p>
<pre><code>UDP сервер запущен на localhost:9090...
Ожидание сообщений от клиента...
</code></pre>
<h3 id="2">Шаг 2: Запустить клиента</h3>
<p>В другом терминале выполните:</p>
<pre><code class="language-bash">python client_udp.py
</code></pre>
<p><strong>Остановка</strong></p>
<p>Для завершения работы сервера нажмите Ctrl+C в терминале.
Клиент завершает работу автоматически после получения ответа.</p>
<h2 id="_6">Код:</h2>
<p><strong>server.py</strong></p>
<pre><code class="language-python">import socket

# Параметры сервера
HOST = 'localhost'  # Адрес хоста
PORT = 9090         # Порт для работы сервера

# Создаем UDP сокет
server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Привязываем сокет к адресу и порту
server_socket.bind((HOST, PORT))
print(f&quot;UDP сервер запущен на {HOST}:{PORT}...&quot;)
print(&quot;Ожидание сообщений от клиента...&quot;)

while True:
    try:
        # Получаем данные от клиента
        data, client_address = server_socket.recvfrom(1024)

        # Декодируем полученное сообщение
        message = data.decode('utf-8')
        print(f&quot;Получено сообщение от {client_address}: {message}&quot;)

        # Ответ для клиента
        response = &quot;Hello, client&quot;

        # Отправляем ответ клиенту
        server_socket.sendto(response.encode('utf-8'), client_address)
        print(f&quot;Отправлен ответ клиенту {client_address}: {response}&quot;)

    except KeyboardInterrupt:
        print(&quot;\nСервер остановлен пользователем&quot;)
        break
    except Exception as e:
        print(f&quot;Ошибка: {e}&quot;)

# Закрываем сокет
server_socket.close()
print(&quot;Сервер завершил работу&quot;)

</code></pre>
<p><strong>client.py</strong></p>
<pre><code class="language-python">import socket

HOST = 'localhost'  # Адрес сервера
PORT = 9090         # Порт сервера

# Создаем UDP сокет
client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

try:
    # Сообщение для сервера
    message = &quot;Hello, server&quot;

    # Отправляем сообщение серверу
    print(f&quot;Отправляю сообщение серверу: {message}&quot;)
    client_socket.sendto(message.encode('utf-8'), (HOST, PORT))

    # Получаем ответ от сервера
    print(&quot;Ожидание ответа от сервера...&quot;)
    data, server_address = client_socket.recvfrom(1024)

    # Декодируем полученный ответ
    response = data.decode('utf-8')
    print(f&quot;Получен ответ от сервера {server_address}: {response}&quot;)

except Exception as e:
    print(f&quot;Ошибка: {e}&quot;)

finally:
    # Закрываем сокет
    client_socket.close()
    print(&quot;Клиент завершил работу&quot;)

</code></pre>
<hr />
<h1 id="2_1">Задание 2.</h1>
<hr />
<h2 id="_7">Описание</h2>
<p>Реализованы клиентская и серверная части приложения на Python с использованием библиотеки <strong>socket</strong> и протокола <strong>TCP</strong>.<br />
Так как в журнале мой порядковый номер 9, я реализовывала функцию <strong>Варианта 1</strong>.
Клиент вводит два числа (катеты прямоугольного треугольника) и отправляет их серверу.<br />
Сервер обрабатывает данные и возвращает клиенту результат вычисления гипотенузы по теореме Пифагора.</p>
<p>Формула:
<code>c = sqrt(a**2 + b**2)</code></p>
<h2 id="_8">Требования</h2>
<ul>
<li>Python 3.6+</li>
<li>Стандартные библиотеки:</li>
<li><code>socket</code></li>
<li><code>math</code></li>
</ul>
<h2 id="_9">Структура проекта</h2>
<ul>
<li><code>server.py</code> — TCP-сервер, обрабатывающий запросы</li>
<li><code>client.py</code> — TCP-клиент для отправки данных</li>
</ul>
<h2 id="_10">Как работает программа</h2>
<ol>
<li>Сервер создаёт TCP-сокет и слушает порт <code>9091</code>.</li>
<li>Клиент подключается к серверу и вводит два числа (катеты <code>a</code> и <code>b</code>).</li>
<li>Клиент отправляет данные серверу.</li>
<li>Сервер вычисляет гипотенузу по формуле <code>√(a² + b²)</code> и отправляет результат обратно.</li>
<li>Клиент выводит результат на экран.</li>
</ol>
<h2 id="_11">Запуск сервера</h2>
<h3 id="1_2">Шаг 1: Запуск сервера</h3>
<p>Откройте терминал и выполните:</p>
<pre><code class="language-bash">cd Task2
python3 server.py
</code></pre>
<p>Вывод будет таким</p>
<pre><code>TCP сервер запущен на localhost:9091, ожидаем подключения...
</code></pre>
<h3 id="2_2">Шаг 2: Запуск клиента</h3>
<p>В другом терминале выполните:</p>
<pre><code class="language-bash">python3 client.py
</code></pre>
<p>Введите катеты.
Например:</p>
<pre><code>Введите катет a: 3
Введите катет b: 4
</code></pre>
<h3 id="3">Шаг 3: Результат</h3>
<ul>
<li>В консоли клиента:</li>
</ul>
<pre><code>Подключено к серверу localhost:9091
Отправлено на сервер: 3 4
Ответ от сервера: Гипотенуза: 5.00
Клиент завершил работу
</code></pre>
<ul>
<li>В консоли сервера:</li>
</ul>
<pre><code>Подключение от ('127.0.0.1', 49485)
Получено от клиента: 3 4
Отправлено клиенту: Гипотенуза: 5.00
Соединение с ('127.0.0.1', 49485) закрыто
</code></pre>
<h3 id="_12">Остановка</h3>
<p>Для завершения работы сервера нажмите Ctrl+C в терминале.
Клиент завершает работу автоматически после получения ответа.</p>
<h2 id="_13">Код:</h2>
<p><strong>server.py</strong></p>
<pre><code class="language-python">import socket
import math

HOST = 'localhost'
PORT = 9091


def handle_client(conn, addr):
    &quot;&quot;&quot;Обработка подключения клиента.&quot;&quot;&quot;
    print(f&quot;Подключение от {addr}&quot;)
    try:
        # Получаем данные от клиента
        data = conn.recv(1024).decode('utf-8')
        print(f&quot;Получено от клиента: {data}&quot;)

        # Ожидаем, что клиент отправит два числа
        parts = data.strip().split()
        if len(parts) != 2:
            response = &quot;Ошибка: введите два числа (катеты a и b)&quot;
        else:
            a, b = map(float, parts)
            c = math.sqrt(a ** 2 + b ** 2)
            response = f&quot;Гипотенуза: {c:.2f}&quot;

        # Отправляем результат клиенту
        conn.sendall(response.encode('utf-8'))
        print(f&quot;Отправлено клиенту: {response}&quot;)

    except Exception as e:
        print(f&quot;Ошибка при обработке клиента {addr}: {e}&quot;)
    finally:
        conn.close()
        print(f&quot;Соединение с {addr} закрыто&quot;)


def start_server():
    &quot;&quot;&quot;Запуск TCP-сервера для вычисления гипотенузы.&quot;&quot;&quot;
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind((HOST, PORT))
    server_socket.listen(5)
    print(f&quot;TCP сервер запущен на {HOST}:{PORT}, ожидаем подключения...&quot;)

    try:
        while True:
            conn, addr = server_socket.accept()
            handle_client(conn, addr)
    except KeyboardInterrupt:
        print(&quot;\nСервер остановлен пользователем&quot;)
    finally:
        server_socket.close()


if __name__ == &quot;__main__&quot;:
    start_server()

</code></pre>
<p><strong>client.py</strong></p>
<pre><code class="language-python">import socket

HOST = 'localhost'
PORT = 9091


def run_client():
    # Создаём TCP-сокет
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    try:
        # Подключаемся к серверу
        client_socket.connect((HOST, PORT))
        print(f&quot;Подключено к серверу {HOST}:{PORT}&quot;)

        # Ввод катетов
        a = input(&quot;Введите катет a: &quot;)
        b = input(&quot;Введите катет b: &quot;)

        # Отправляем данные серверу
        message = f&quot;{a} {b}&quot;
        client_socket.sendall(message.encode('utf-8'))
        print(f&quot;Отправлено на сервер: {message}&quot;)

        # Получаем ответ
        response = client_socket.recv(1024).decode('utf-8')
        print(f&quot;Ответ от сервера: {response}&quot;)

    except Exception as e:
        print(f&quot;Ошибка клиента: {e}&quot;)
    finally:
        client_socket.close()
        print(&quot;Клиент завершил работу&quot;)


if __name__ == &quot;__main__&quot;:
    run_client()

</code></pre>
<hr />
<h1 id="3_1">Задание 3.</h1>
<hr />
<h2 id="_14">Описание</h2>
<p>Реализована серверная часть приложения на Python.<br />
Клиент подключается к серверу, и в ответ получает HTTP-сообщение, содержащее HTML-страницу <code>index.html</code>.</p>
<h2 id="_15">Требования</h2>
<ul>
<li>Python 3.6+</li>
<li>Стандартные библиотеки:</li>
<li><code>socket</code></li>
<li><code>os</code></li>
<li><code>mimetypes</code></li>
</ul>
<h2 id="_16">Структура проекта</h2>
<ul>
<li><code>server.py</code> — код HTTP-сервера</li>
<li><code>index.html</code> — HTML-страница, отдаваемая сервером</li>
</ul>
<h2 id="_17">Как работает сервер</h2>
<ol>
<li>Создаётся TCP-сокет и привязывается к адресу <code>localhost:9093</code>.</li>
<li>Сервер ждёт подключения клиентов.</li>
<li>При получении HTTP-запроса сервер:</li>
<li>разбирает метод и путь;</li>
<li>обрабатывает только метод <strong>GET</strong>;</li>
<li>по умолчанию отдаёт <code>index.html</code>;</li>
<li>определяет MIME-тип файла;</li>
<li>формирует корректный HTTP-ответ и отправляет клиенту.</li>
<li>При ошибках возвращаются страницы с кодами:</li>
<li><strong>404 Not Found</strong> — файл не найден;</li>
<li><strong>405 Method Not Allowed</strong> — если запрос не GET;</li>
<li><strong>500 Internal Server Error</strong> — при сбое обработки.</li>
</ol>
<h2 id="_18">Запуск сервера</h2>
<h3 id="1-http-">Шаг 1: Запуск HTTP-сервера</h3>
<p>Откройте терминал и выполните:</p>
<pre><code class="language-bash">cd Task3
python3 server.py
</code></pre>
<p>Сервер запустится на localhost:8082 и будет ожидать HTTP-запросы.</p>
<h3 id="2_3">Шаг 2: Открытие в браузере</h3>
<p>Откройте браузер и перейдите по адресу:</p>
<pre><code>http://localhost:8082
</code></pre>
<p>Вы увидите красивую HTML-страницу с информацией о выполненном задании.</p>
<p><strong>Остановка</strong></p>
<p>Для завершения работы сервера нажмите Ctrl+C в терминале.</p>
<h2 id="_19">Обработка ошибок</h2>
<h3 id="404-not-found">404 Not Found</h3>
<p>Если запрашиваемый файл не найден, сервер возвращает страницу с ошибкой 404.</p>
<h3 id="500-internal-server-error">500 Internal Server Error</h3>
<p>При внутренних ошибках сервера возвращается страница с ошибкой 500.</p>
<h3 id="405-method-not-allowed">405 Method Not Allowed</h3>
<p>Сервер поддерживает только GET-запросы.</p>
<h2 id="_20">Код:</h2>
<p><strong>server.py</strong></p>
<pre><code class="language-python">import socket
import mimetypes

HOST = 'localhost'
PORT = 9093


def get_file_content(filename):
    try:
        with open(filename, 'rb') as file:
            return file.read()
    except FileNotFoundError:
        return None
    except Exception as e:
        print(f&quot;Ошибка чтения файла {filename}: {e}&quot;)
        return None


def get_content_type(filename):
    &quot;&quot;&quot;Определение MIME-типа файла&quot;&quot;&quot;
    mime_type, _ = mimetypes.guess_type(filename)
    return mime_type if mime_type else 'text/plain'

def create_http_response(status_code, content_type, content):
    &quot;&quot;&quot;Создание HTTP-ответа&quot;&quot;&quot;
    status_messages = {
        200: &quot;OK&quot;,
        404: &quot;Not Found&quot;,
        500: &quot;Internal Server Error&quot;
    }

    status_line = f&quot;HTTP/1.1 {status_code} {status_messages.get(status_code, 'Unknown')}&quot;
    headers = [
        f&quot;Content-Type: {content_type}; charset=UTF-8&quot;,
        f&quot;Content-Length: {len(content)}&quot;,
        &quot;Connection: close&quot;,
        &quot;Server: Python-HTTP-Server/1.0&quot;
    ]

    response = f&quot;{status_line}\r\n&quot;
    response += &quot;\r\n&quot;.join(headers)
    response += &quot;\r\n\r\n&quot;

    return response.encode('utf-8') + content


def handle_request(request_data):
    &quot;&quot;&quot;Обработка HTTP-запроса&quot;&quot;&quot;
    try:
        lines = request_data.decode('utf-8').split('\n')
        if not lines:
            return create_http_response(400, 'text/plain', b'Bad Request')

        request_line = lines[0].strip()
        parts = request_line.split()

        if len(parts) &lt; 2:
            return create_http_response(400, 'text/plain', b'Bad Request')

        method = parts[0]
        path = parts[1]

        print(f&quot;Запрос: {method} {path}&quot;)

        # Обрабатываем только GET запросы
        if method != 'GET':
            return create_http_response(405, 'text/plain', b'Method Not Allowed')

        # По умолчанию отдаем index.html
        if path == '/' or path == '/index.html':
            filename = 'index.html'
        else:
            filename = path.lstrip('/')

        # Читаем содержимое файла
        content = get_file_content(filename)

        if content is None:
            # Файл не найден
            error_content = &quot;&quot;&quot;
            &lt;html&gt;
            &lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;
            &lt;body&gt;
                &lt;h1&gt;404 - Страница не найдена&lt;/h1&gt;
                &lt;p&gt;Запрашиваемый файл не найден на сервере.&lt;/p&gt;
                &lt;a href=&quot;/&quot;&gt;Вернуться на главную&lt;/a&gt;
            &lt;/body&gt;
            &lt;/html&gt;
            &quot;&quot;&quot;.encode('utf-8')
            return create_http_response(404, 'text/html', error_content)

        # Определяем MIME-тип
        content_type = get_content_type(filename)

        # Создаем успешный ответ
        return create_http_response(200, content_type, content)

    except Exception as e:
        print(f&quot;Ошибка обработки запроса: {e}&quot;)
        error_content = &quot;&quot;&quot;
        &lt;html&gt;
        &lt;head&gt;&lt;title&gt;500 Internal Server Error&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;500 - Внутренняя ошибка сервера&lt;/h1&gt;
            &lt;p&gt;Произошла ошибка при обработке запроса.&lt;/p&gt;
        &lt;/body&gt;
        &lt;/html&gt;
        &quot;&quot;&quot;.encode('utf-8')
        return create_http_response(500, 'text/html', error_content)


def main():
    &quot;&quot;&quot;Основная функция сервера&quot;&quot;&quot;
    # Создаем TCP сокет
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    # Позволяем повторно использовать адрес
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    try:
        # Привязываем сокет к адресу и порту
        server_socket.bind((HOST, PORT))

        # Начинаем слушать входящие соединения
        server_socket.listen(5)
        print(f&quot;HTTP сервер запущен на {HOST}:{PORT}&quot;)
        print(&quot;Откройте браузер и перейдите по адресу: http://localhost:9093&quot;)
        print(&quot;Для остановки сервера нажмите Ctrl+C&quot;)

        while True:
            # Принимаем соединение от клиента
            client_connection, client_address = server_socket.accept()
            print(f'Подключение от {client_address}')

            try:
                # Получаем HTTP-запрос
                request_data = client_connection.recv(4096)

                if request_data:
                    # Обрабатываем запрос и получаем ответ
                    response = handle_request(request_data)

                    # Отправляем ответ клиенту
                    client_connection.sendall(response)
                    print(f'Ответ отправлен клиенту {client_address}')

            except Exception as e:
                print(f&quot;Ошибка при обработке клиента {client_address}: {e}&quot;)
            finally:
                # Закрываем соединение
                client_connection.close()

    except KeyboardInterrupt:
        print(&quot;\nСервер остановлен пользователем&quot;)
    except Exception as e:
        print(f&quot;Ошибка сервера: {e}&quot;)
    finally:
        # Закрываем сокет
        server_socket.close()
        print(&quot;Сервер завершил работу&quot;)


if __name__ == &quot;__main__&quot;:
    main()

</code></pre>
<p><strong>index.html</strong></p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang=&quot;ru&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;Web-программирование — ЛР1, Задание 3&lt;/title&gt;
  &lt;style&gt;
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 2rem;
      background: #121212;
      color: #f0f0f0;
      text-align: center;
      line-height: 1.6;
    }
    h1 {
      font-size: 1.6rem;
      margin-bottom: 1rem;
    }
    p {
      margin: 0.5rem 0;
    }
    footer {
      margin-top: 3rem;
    }
    footer img {
      display: block;
      margin: 0 auto;
      max-width: 200px;
      height: auto;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Web-программирование&lt;/h1&gt;
  &lt;p&gt;Лабораторная работа 1&lt;/p&gt;
  &lt;p&gt;Задание 3&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;Мой Python-сервер передаёт привет!&lt;/strong&gt;&lt;/p&gt;
  &lt;p&gt;Эта страница была загружена с помощью сокетов.&lt;/p&gt;

&lt;footer&gt;
    &lt;img src=&quot;/img/2.png&quot; alt=&quot;Котик пишет код&quot;&gt;
    &lt;p class=&quot;greeting&quot;&gt;Хорошего дня!&lt;/p&gt;
  &lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr />
<h1 id="4">Задание 4</h1>
<hr />
<h2 id="_21">Описание</h2>
<p>Реализованы клиентская и серверная части <strong>многопользовательского чата</strong> на Python с использованием библиотеки <strong>socket</strong> и протокола <strong>TCP</strong>.<br />
Для одновременной работы нескольких клиентов используется <strong>threading</strong>.</p>
<ul>
<li>Каждый клиент при подключении отправляет серверу свой <strong>никнейм</strong>.</li>
<li>Все сообщения клиента рассылаются <strong>всем остальным</strong> участникам.</li>
<li>Команда выхода: <strong><code>/quit</code></strong>.</li>
</ul>
<h2 id="_22">Требования</h2>
<ul>
<li>Python 3.6+</li>
<li>Стандартные библиотеки:</li>
<li><code>socket</code></li>
<li><code>threading</code></li>
</ul>
<h2 id="_23">Структура проекта</h2>
<ul>
<li><code>server.py</code> — TCP-сервер: принимает подключения, хранит список клиентов, рассылает сообщения.</li>
<li><code>client.py</code> — TCP-клиент: отправляет сообщения и получает рассылку в отдельном потоке.</li>
</ul>
<h2 id="_24">Как работает программа</h2>
<ol>
<li>Сервер создаёт TCP-сокет и слушает <code>127.0.0.1:9094</code>.</li>
<li>Клиент подключается к серверу, <strong>вводит ник</strong> и отправляет его первой строкой.</li>
<li>Сервер сохраняет сокет клиента и ник; оповещает остальных о подключении.</li>
<li>Любое сообщение клиента пересылается сервером всем остальным участникам.</li>
<li>При вводе <code>/quit</code> клиент отключается; сервер уведомляет остальных.</li>
</ol>
<h2 id="_25">Запуск</h2>
<h3 id="1_3">Шаг 1: Запуск сервера</h3>
<p>Откройте терминал и выполните:</p>
<pre><code class="language-bash">cd Task4
python3 server.py
</code></pre>
<h3 id="2_4">Шаг 2: Запуск клиента</h3>
<p>В другом терминале выполните:</p>
<pre><code class="language-bash">python3 client.py
</code></pre>
<h3 id="3_2">Шаг 3: Начните переписку</h3>
<p>Пример:</p>
<pre><code>Введите ник: Ананас
&gt; Привет
</code></pre>
<h3 id="_26">Пример работы</h3>
<p>Клиент A</p>
<pre><code>Введите ник: Ананас
&gt;
[+] Ананас присоединился
&gt;
[+] Яблоко присоединился
&gt;
[+] Груша присоединился
&gt; Привет
&gt;
Яблоко: Пока
&gt;
Груша: окак
&gt;
</code></pre>
<p>Клиент B</p>
<pre><code>Введите ник: Яблоко

[+] Яблоко присоединился
&gt; &gt;
[+] Груша присоединился
&gt;
Ананас: Привет
&gt; Пока
&gt;
Груша: окак
&gt;
</code></pre>
<p>Клиент C</p>
<pre><code>Введите ник: Груша
&gt;
[+] Груша присоединился
&gt;
Ананас: Привет
&gt;
Яблоко: Пока
&gt; окак
&gt;
</code></pre>
<p>Сервер</p>
<pre><code>('127.0.0.1', 63575) -&gt; Ананас
('127.0.0.1', 63629) -&gt; Яблоко
('127.0.0.1', 63708) -&gt; Груша
</code></pre>
<h2 id="_27">Код:</h2>
<p><strong>server.py</strong></p>
<pre><code class="language-python">import socket
import threading

HOST = &quot;127.0.0.1&quot;
PORT = 9094

clients = []
nicknames = {}
lock = threading.Lock()


def broadcast(text, sender=None):
    &quot;&quot;&quot;Отправка текстового сообщения всем клиентам.&quot;&quot;&quot;
    dead = []
    with lock:
        for sock in clients:
            if sender is not None and sock is sender:
                continue
            try:
                sock.sendall((text + &quot;\n&quot;).encode(&quot;utf-8&quot;))
            except OSError:
                dead.append(sock)
        for s in dead:
            if s in clients:
                clients.remove(s)
            nicknames.pop(s, None)
            try:
                s.close()
            except OSError:
                pass


def handle_client(sock, addr):
    &quot;&quot;&quot;Обработка одного клиента в отдельном потоке.&quot;&quot;&quot;
    try:
        # первая полученная строка — ник
        raw = sock.recv(1024)
        nickname = raw.decode(&quot;utf-8&quot;).strip() if raw else &quot;&quot;
        if not nickname:
            nickname = f&quot;user_{addr[1]}&quot;

        with lock:
            clients.append(sock)
            nicknames[sock] = nickname

        broadcast(f&quot;[+] {nickname} присоединился&quot;)
        print(f&quot;{addr} -&gt; {nickname}&quot;)

        while True:
            data = sock.recv(4096)
            if not data:
                break
            msg = data.decode(&quot;utf-8&quot;).rstrip(&quot;\r\n&quot;)
            if msg.lower() == &quot;/quit&quot;:
                break
            broadcast(f&quot;{nickname}: {msg}&quot;, sender=sock)
    except OSError:
        pass
    finally:
        with lock:
            if sock in clients:
                clients.remove(sock)
            name = nicknames.pop(sock, &quot;unknown&quot;)
        broadcast(f&quot;[-] {name} вышел&quot;)
        try:
            sock.close()
        except OSError:
            pass
        print(f&quot;{addr} disconnected&quot;)


def main():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind((HOST, PORT))
    server.listen(10)
    print(f&quot;Сервер: {HOST}:{PORT}&quot;)

    try:
        while True:
            client_sock, client_addr = server.accept()
            threading.Thread(
                target=handle_client, args=(client_sock, client_addr), daemon=True
            ).start()
    except KeyboardInterrupt:
        print(&quot;\nСтоп&quot;)
    finally:
        with lock:
            for s in clients:
                try:
                    s.close()
                except OSError:
                    pass
            clients.clear()
            nicknames.clear()
        server.close()


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<p><strong>client.py</strong></p>
<pre><code class="language-python">import socket
import threading

HOST = &quot;127.0.0.1&quot;
PORT = 9094

print_lock = threading.Lock()


def receiver(sock: socket.socket) -&gt; None:
    &quot;&quot;&quot;Читает входящие сообщения и печатает их с новой строки.&quot;&quot;&quot;
    try:
        while True:
            data = sock.recv(4096)
            if not data:
                with print_lock:
                    print(&quot;\n[Соединение закрыто сервером]&quot;)
                break
            text = data.decode(&quot;utf-8&quot;)
            with print_lock:
                # печатаем входящее и возвращаем
                print(f&quot;\n{text}&quot;, end=&quot;&quot;)
                print(&quot;&gt; &quot;, end=&quot;&quot;, flush=True)
    except OSError:
        pass
    finally:
        try:
            sock.close()
        except OSError:
            pass


def main() -&gt; None:
    nickname = input(&quot;Введите ник: &quot;).strip() or &quot;user&quot;

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))

    # отправляем ник первой строкой
    sock.sendall((nickname + &quot;\n&quot;).encode(&quot;utf-8&quot;))

    # запускаем поток-приёмник
    threading.Thread(target=receiver, args=(sock,), daemon=True).start()

    #Чтобы было можно печать во время отправки сообщений
    with print_lock:
        print(&quot;&gt; &quot;, end=&quot;&quot;, flush=True)

    try:
        while True:
            msg = input()
            if msg.strip().lower() == &quot;/quit&quot;:
                sock.sendall(b&quot;/quit\n&quot;)
                break
            sock.sendall((msg + &quot;\n&quot;).encode(&quot;utf-8&quot;))
            with print_lock:
                print(&quot;&gt; &quot;, end=&quot;&quot;, flush=True)
    except KeyboardInterrupt:
        pass
    finally:
        try:
            sock.close()
        except OSError:
            pass
        with print_lock:
            print(&quot;\nКлиент завершил работу&quot;)


if __name__ == &quot;__main__&quot;:
    main()

</code></pre>
<hr />
<h1 id="5">Задание 5</h1>
<hr />
<h2 id="_28">Описание</h2>
<p>Реализована серверная часть приложения на Python c использованием <code>socket</code>.
Клиент открывает страницу журнала <code>index.html</code>.
Сервер принимает оценки через <strong>POST</strong>, сохраняет их в <code>grades.json</code> и на <strong>GET</strong> отдаёт HTML-страницу со сводной таблицей (одна строка на дисциплину, в ячейке — список её оценок).</p>
<h2 id="_29">Требования</h2>
<ul>
<li>Python 3.7+</li>
<li>
<p>Стандартные библиотеки:</p>
</li>
<li>
<p><code>socket</code></p>
</li>
<li><code>urllib.parse</code></li>
<li><code>json</code></li>
<li><code>os</code></li>
</ul>
<h2 id="_30">Структура проекта</h2>
<ul>
<li><code>server.py</code> — HTTP-сервер (обрабатывает <code>GET /</code> и <code>POST /add</code>)</li>
<li><code>data_store.py</code> — простое хранилище данных (чтение/запись <code>grades.json</code>)</li>
<li><code>index.html</code> — HTML-шаблон страницы журнала</li>
<li><code>grades.json</code> — файл с данными (создаётся автоматически при первой записи)</li>
</ul>
<h2 id="_31">Коды ответов:</h2>
<ul>
<li><strong>200 OK</strong> — успешная выдача страницы,</li>
<li><strong>303 See Other</strong> — после успешного <code>POST</code>,</li>
<li><strong>400 Bad Request</strong> — некорректный формат запроса,</li>
<li><strong>404 Not Found</strong> — неизвестный путь,</li>
<li><strong>405 Method Not Allowed</strong> — методы, кроме GET/POST.</li>
</ul>
<h2 id="_32">Клиентская валидация</h2>
<p>В <code>index.html</code> есть JavaScript-проверка: при неверной оценке кнопка «Добавить» загорается красным, показана подсказка, отправка формы блокируется.
Серверная проверка остаётся обязательной (на случай обхода фронтенда).</p>
<h2 id="_33">Запуск сервера</h2>
<h3 id="1_4">Шаг 1: запуск</h3>
<p>Откройте терминал в папке проекта и выполните:</p>
<pre><code class="language-bash">python server.py
</code></pre>
<h3 id="2_5">Шаг 2: открыть в браузере</h3>
<p>Перейдите по адресу:</p>
<pre><code>http://127.0.0.1:8080
</code></pre>
<p>Вы увидите страницу «Журнал оценок» с формой добавления и таблицей.</p>
<p><strong>Остановка:</strong> <code>Ctrl + C</code> в терминале.</p>
<h2 id="_34">Формат данных</h2>
<p>Файл <code>grades.json</code> хранит словарь «дисциплина → список оценок», например:</p>
<pre><code class="language-json">{
  &quot;Математика&quot;: [&quot;5&quot;, &quot;4&quot;],
  &quot;Физика&quot;: [&quot;0,01&quot;]
}
</code></pre>
<h2 id="_35">Код:</h2>
<p><strong>data_store.py</strong></p>
<pre><code class="language-python">&quot;&quot;&quot;
Формат файла grades.json:
{
  &quot;Математика&quot;: [&quot;5&quot;, &quot;4&quot;],
  &quot;Физика&quot;: [&quot;0,01&quot;]
}
&quot;&quot;&quot;

import json
import os
from typing import Dict, List

FILE_PATH = &quot;grades.json&quot;


def _load() -&gt; Dict[str, List[str]]:
    &quot;&quot;&quot;Загружаем словарь дисциплин и оценок из JSON, если файла нет — пустой словарь.&quot;&quot;&quot;
    if not os.path.exists(FILE_PATH):
        return {}
    try:
        with open(FILE_PATH, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
            return json.load(f)
    except (json.JSONDecodeError, OSError):
        return {}


def _save(data: Dict[str, List[str]]) -&gt; None:
    &quot;&quot;&quot;Сохраняем словарь в JSON.&quot;&quot;&quot;
    with open(FILE_PATH, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
        json.dump(data, f, ensure_ascii=False, indent=2)


def add_grade(discipline: str, grade: str) -&gt; None:
    &quot;&quot;&quot;Добавляем оценку к дисциплине.&quot;&quot;&quot;
    data = _load()
    discipline = discipline.strip()
    grade = grade.strip()
    if not discipline or not grade:
        return
    data.setdefault(discipline, []).append(grade)
    _save(data)


def get_all() -&gt; Dict[str, List[str]]:
    &quot;&quot;&quot;Возвращаем весь журнал.&quot;&quot;&quot;
    return _load()

</code></pre>
<h2 id="_36">Код:</h2>
<p><strong>server.py</strong></p>
<pre><code class="language-python">import socket
import urllib.parse
from typing import Tuple, Dict
import data_store

HOST = &quot;127.0.0.1&quot;
PORT = 9095


def build_response(status: str, headers: Dict[str, str], body: str = &quot;&quot;) -&gt; bytes:
    &quot;&quot;&quot;Формируем HTTP-ответ.&quot;&quot;&quot;
    body_bytes = body.encode(&quot;utf-8&quot;)
    headers = {
        &quot;Content-Type&quot;: &quot;text/html; charset=utf-8&quot;,
        &quot;Connection&quot;: &quot;close&quot;,
        &quot;Content-Length&quot;: str(len(body_bytes)),
        **headers,
    }
    lines = [f&quot;HTTP/1.1 {status}&quot;] + [f&quot;{k}: {v}&quot; for k, v in headers.items()]
    head = &quot;\r\n&quot;.join(lines) + &quot;\r\n\r\n&quot;
    return head.encode(&quot;utf-8&quot;) + body_bytes


def parse_request(data: bytes) -&gt; Tuple[str, str, Dict[str, str], bytes]:
    try:
        head, body = data.split(b&quot;\r\n\r\n&quot;, 1)
    except ValueError:
        return &quot;&quot;, &quot;&quot;, {}, b&quot;&quot;

    lines = head.decode(&quot;iso-8859-1&quot;).split(&quot;\r\n&quot;)
    if not lines or &quot; &quot; not in lines[0]:
        return &quot;&quot;, &quot;&quot;, {}, b&quot;&quot;

    method, path, *_ = lines[0].split(&quot; &quot;)

    headers: Dict[str, str] = {}
    for line in lines[1:]:
        if &quot;:&quot; in line:
            k, v = line.split(&quot;:&quot;, 1)
            headers[k.strip().lower()] = v.strip()

    return method, path, headers, body


def handle_get(path: str) -&gt; bytes:
    &quot;&quot;&quot;Обработка GET-запросов.&quot;&quot;&quot;
    if path == &quot;/&quot;:
        data = data_store.get_all()
        disciplines = sorted(data.keys(), key=lambda s: s.lower())

        # Формируем строки таблицы
        rows = []
        for d in disciplines:
            grades = &quot;; &quot;.join(escape_html(g) for g in data[d])
            rows.append(f&quot;&lt;tr&gt;&lt;td&gt;{escape_html(d)}&lt;/td&gt;&lt;td&gt;{grades}&lt;/td&gt;&lt;/tr&gt;&quot;)
        rows_html = &quot;\n&quot;.join(rows) if rows else '&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;Пока пусто&lt;/td&gt;&lt;/tr&gt;'

        # Читаем index.html
        try:
            with open(&quot;index.html&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
                template = f.read()
        except FileNotFoundError:
            return build_response(&quot;500 Internal Server Error&quot;, {}, &quot;index.html not found&quot;)

        html = template.replace(&quot;{{rows}}&quot;, rows_html)
        return build_response(&quot;200 OK&quot;, {}, html)

    return build_response(&quot;404 Not Found&quot;, {}, &quot;Not Found&quot;)


def _is_positive_number(text: str) -&gt; bool:
    &quot;&quot;&quot;
    Возвращает True, если строка — положительное число &gt; 0.
    &quot;&quot;&quot;
    norm = text.replace(&quot;,&quot;, &quot;.&quot;)
    try:
        return float(norm) &gt; 0.0
    except ValueError:
        return False


def handle_post(path: str, headers: Dict[str, str], body: bytes) -&gt; bytes:
    &quot;&quot;&quot;Обработка POST-запросов.&quot;&quot;&quot;
    if path == &quot;/add&quot;:
        if &quot;application/x-www-form-urlencoded&quot; not in headers.get(&quot;content-type&quot;, &quot;&quot;):
            return build_response(&quot;400 Bad Request&quot;, {}, &quot;Expected x-www-form-urlencoded&quot;)

        form = urllib.parse.parse_qs(body.decode(&quot;utf-8&quot;), keep_blank_values=True)
        discipline = (form.get(&quot;discipline&quot;, [&quot;&quot;])[0]).strip()
        grade_raw = (form.get(&quot;grade&quot;, [&quot;&quot;])[0]).strip()

        # Серверная проверка: положительное число &gt; 0 (целое или дробное, . или ,)
        if discipline and _is_positive_number(grade_raw):
            data_store.add_grade(discipline, grade_raw)

        return build_response(&quot;303 See Other&quot;, {&quot;Location&quot;: &quot;/&quot;}, &quot;&quot;)

    return build_response(&quot;404 Not Found&quot;, {}, &quot;Not Found&quot;)


def escape_html(s: str) -&gt; str:
    &quot;&quot;&quot;Экранирование спецсимволов в HTML.&quot;&quot;&quot;
    return (
        s.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)
         .replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)
         .replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)
         .replace('&quot;', &quot;&amp;quot;&quot;)
         .replace(&quot;'&quot;, &quot;&amp;#39;&quot;)
    )


def serve():
    &quot;&quot;&quot;Главный цикл сервера.&quot;&quot;&quot;
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as srv:
        srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        srv.bind((HOST, PORT))
        srv.listen(5)
        print(f&quot;Server running at http://{HOST}:{PORT}&quot;)

        while True:
            conn, _ = srv.accept()
            with conn:
                try:
                    raw = conn.recv(65535)
                    method, path, headers, body = parse_request(raw)
                    length = int(headers.get(&quot;content-length&quot;, &quot;0&quot;))
                    while len(body) &lt; length:
                        chunk = conn.recv(65535)
                        if not chunk:
                            break
                        body += chunk
                except (socket.timeout, ValueError, UnicodeDecodeError):
                    conn.sendall(build_response(&quot;400 Bad Request&quot;, {}, &quot;Bad Request&quot;))
                    continue

                if method == &quot;GET&quot;:
                    resp = handle_get(path)
                elif method == &quot;POST&quot;:
                    resp = handle_post(path, headers, body)
                else:
                    resp = build_response(&quot;405 Method Not Allowed&quot;, {&quot;Allow&quot;: &quot;GET, POST&quot;}, &quot;Method Not Allowed&quot;)

                conn.sendall(resp)


if __name__ == &quot;__main__&quot;:
    serve()

</code></pre>
<h2 id="_37">Код:</h2>
<p><strong>index.html</strong></p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang=&quot;ru&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Журнал&lt;/title&gt;
  &lt;style&gt;
    body {
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 800px;
      margin: 40px auto;
      background: #fff;
      padding: 24px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    h1 {
      margin-top: 0;
      color: #333;
    }
    form {
      margin: 20px 0;
      display: grid;
      grid-template-columns: 1fr 1fr auto;
      gap: 10px;
      align-items: center;
    }
    input, button {
      padding: 10px;
      font-size: 14px;
    }
    input {
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .btn {
      background-color: #4a4a4a;
      color: #fff;
      border: none;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.2s, transform 0.05s;
    }
    .btn:hover { background-color: #333; }
    .btn:active { transform: translateY(1px); }
    /* Состояние ошибки: красная кнопка */
    .btn.error { background-color: #c62828; }
    .hint {
      grid-column: 1 / -1;
      color: #a00;
      font-size: 13px;
      display: none;
      margin-top: -6px;
    }
    .hint.show { display: block; }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 16px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 10px;
      text-align: left;
    }
    th { background: #eee; }
    tr:nth-child(even) { background: #fafafa; }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;h1&gt;Журнал&lt;/h1&gt;

    &lt;form id=&quot;grade-form&quot; method=&quot;POST&quot; action=&quot;/add&quot; novalidate&gt;
      &lt;input id=&quot;discipline&quot; name=&quot;discipline&quot; placeholder=&quot;Дисциплина&quot; required /&gt;
      &lt;input id=&quot;grade&quot; name=&quot;grade&quot; placeholder=&quot;Оценка (&gt; 0, можно дробную)&quot; required /&gt;
      &lt;button id=&quot;submitBtn&quot; class=&quot;btn&quot; type=&quot;submit&quot;&gt;Добавить&lt;/button&gt;
      &lt;div id=&quot;hint&quot; class=&quot;hint&quot;&gt;
        Оценка должна быть положительным числом (целым или дробным; разделитель «.» или «,»).
      &lt;/div&gt;
    &lt;/form&gt;

    &lt;table&gt;
      &lt;tr&gt;&lt;th&gt;Дисциплина&lt;/th&gt;&lt;th&gt;Оценки&lt;/th&gt;&lt;/tr&gt;
      {{rows}}
    &lt;/table&gt;
  &lt;/div&gt;

  &lt;script&gt;
    // Клиентская валидация: положительное число &gt; 0, допускаем дробные с . или ,
    (function () {
      const form = document.getElementById('grade-form');
      const gradeInput = document.getElementById('grade');
      const submitBtn = document.getElementById('submitBtn');
      const hint = document.getElementById('hint');

      function isPositiveNumber(value) {
        // Разрешаем форму: &quot;123&quot;, &quot;0,5&quot;, &quot;4.25&quot;
        const trimmed = value.trim();
        if (!/^\d+([.,]\d+)?$/.test(trimmed)) return false;
        const num = parseFloat(trimmed.replace(',', '.'));
        return Number.isFinite(num) &amp;&amp; num &gt; 0;
      }

      function clearError() {
        submitBtn.classList.remove('error');
        hint.classList.remove('show');
      }

      gradeInput.addEventListener('input', clearError);
      form.addEventListener('input', clearError);

      form.addEventListener('submit', function (e) {
        const grade = gradeInput.value;
        if (!isPositiveNumber(grade)) {
          e.preventDefault();
          submitBtn.classList.add('error');
          hint.classList.add('show');
        }
      });
    })();
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": ".", "features": [], "search": "assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="assets/javascripts/bundle.f55a23d4.min.js"></script>
      
    
  </body>
</html>